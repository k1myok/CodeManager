define(["dojo/_base/declare", "esri/geometry/Point", "esri/geometry/ScreenPoint", "esri/SpatialReference", "esri/geometry/webMercatorUtils", "../common/Class", "../common/WMapUtils", "./Drawer"], function (t, e, a, i, r, n, s, o) { return t("DensityDrawer", [o], { min: null, max: null, r: 0, g: 0, b: 0, _this: {}, constructor: function () { this.inherited(arguments), this.Scale = null, this.masker = {}, this.init() }, drawMap: function () { this.beginDrawMap(); for (var t = this.getLayer().getData(), e = this.getCtx(), a = this.getDrawOptions(), i = this.getRadius(), r = 0, n = t.length; n > r; r++) { var s = t[r]; e.beginPath(), e.moveTo(s.px, s.py), e.fillStyle = this.dataRange.getCategoryColor(s.count), e.arc(s.px, s.py, i, 0, 2 * Math.PI), e.closePath(), e.fill() } a.strokeStyle && e.stroke(), this.endDrawMap() }, init: function () { function t(t) { a.mapEvent.addEvent(t, function (a) { var r = null; if ("honeycomb" == i.type) { var n = a.offsetX, s = a.offsetY, o = Math.round((s - e._this.startY) / e._this.depthY), l = o * e._this.depthY + e._this.startY, h = Math.round((n - e._this.startX) / e._this.depthX), m = h * e._this.depthX + e._this.startX; o % 2 && (m -= e._this.depthX / 2), r = e.grids[m + "|" + l].len } else for (var p in e.grids) { var c = p.split("_"); if (a.offsetX - c[0] <= e._this.gridStep && a.offsetY - c[1] <= e._this.gridStep) { r = e.grids[p]; break } } i.events[t](a, r) }) } var e = this, a = this.getMapv(), i = this.getDrawOptions(); if (i.events) for (var r in i.events) t(r) }, scale: function (t) { var e = this; t.change(function (t, a) { e.masker = { min: t, max: a }, e.ctx = e.getCtx(), e.ctx.clearRect(0, 0, e.ctx.canvas.width, e.ctx.canvas.height), e.drawMap() }), this.Scale = t }, drawMap: function () { this.beginDrawMap(); var t, a = this, n = this.getCtx(), s = this.getLayer().getData(), o = this.getMapv().getMap(), l = this.zoomUnit = o.extent.getWidth() / o.width, h = this.mapZoom = o.getZoom(), m = a.formatParam.call(this), p = m.size, c = o.position, g = this.pixel2GeoCoord(c); if (4326 === g.spatialReference.wkid) { var v = r.xyToLngLat(g.x, g.y); t = new e(v[0], v[1], new i(102100)) } else t = g; var d = { data: s, nwMc: t, size: p, zoomUnit: l, ctx: n }, f = {}; f = "honeycomb" === this.getDrawOptions().type ? a.honeycombGrid(d) : a.recGrids(d, o); var w = this.grids = f.grids; this.dataRange.setMax(f.max), this.dataRange.setMin(f.min); var x = f.max, u = f.min, d = { size: p, zoomUnit: l, max: x, min: u, ctx: n, grids: w, fillColors: m.colors, dataRange: this.dataRange, sup: a, mapZoom: h, drowZero: !1 }, f = {}; "honeycomb" === this.getDrawOptions().type ? a.drawHoneycomb.call(this, d) : a.drawRec.call(this, d), this.Scale && this.Scale.set({ max: x, min: u, colors: this.getDrawOptions().gradient || "default" }), this.endDrawMap() }, recGrids: function (t, e) { for (var a, i, r = t.data, n = t.nwMc, s = t.size, o = t.zoomUnit, l = {}, h = this._this.gridStep = parseInt(s / o, 10), m = parseInt(n.x / s, 10) * s, p = (m - n.x) / o, c = [], g = 0; p + g * h < e.width;) { var v = p + g * h; c.push(v.toFixed(2)), g++ } for (var d = parseInt(n.y / s, 10) * s + s, f = (n.y - d) / o, w = [], x = 0; f + x * h < e.height;) v = f + x * h, w.push(v.toFixed(2)), x++; for (var u = 0; u < c.length; u++) for (var y = 0; y < w.length; y++) { var S = c[u] + "_" + w[y]; l[S] = 0 } for (var u = 0; u < r.length; u++) { var b = r[u].px, L = r[u].py, M = parseInt(r[u].count, 10), _ = b < c[0], D = L < w[0], z = b > Number(c[c.length - 1]) + Number(h), I = L > Number(w[w.length - 1]) + Number(h); if (!(_ || D || z || I)) { for (var y = 0; y < c.length; y++) { var O = Number(c[y]); if (b >= O && O + h > b) for (var C = 0; C < w.length; C++) { var R = Number(w[C]); L >= R && R + h > L && (l[c[y] + "_" + w[C]] += M, M = l[c[y] + "_" + w[C]]) } } i = i || M, a = a || M, i = i > M ? M : i, a = M > a ? M : a } } return { grids: l, max: a, min: i } }, drawRec: function (t) { var e = this, a = t.size, i = t.zoomUnit, r = t.max, n = t.min, s = t.ctx, o = t.grids, l = (t.fillColors, t.sup), h = e.formatParam.call(this), m = t.mapZoom, p = t.sup.getDrawOptions().drowZero || !1, c = a / i, g = (r - n + 1) / 10; for (var v in o) { var d = v.split("_"), f = d[0], w = d[1], x = ((o[v] - n) / g, t.dataRange.getColorByGradient(o[v])); try { if (h.opacity) { var u = x.match(/rgba\(.+?\,.+?\,.+?\,(.+?)\)/)[1] * h.opacity; x = x.replace(/(rgba\(.+?\,.+?\,.+?\,).+?(\))/, "$1" + u + "$2") } } catch (y) { } var S = l.masker.min && o[v] < l.masker.min, b = l.masker.max && o[v] > l.masker.max; if (0 === o[v] || S || b ? p && (s.fillStyle = "rgba(255,255,255,0.1)", s.fillRect(f, w, c - 1, c - 1)) : (s.fillStyle = x, s.fillRect(f, w, c - 1, c - 1)), l.getDrawOptions().label && l.getDrawOptions().label.show && !S && !b) { var L = l.getDrawOptions().label; (!L.minShowLevel && !L.maxShowLevel || L.minShowLevel && L.maxShowLevel && L.minShowLevel <= m && L.maxShowLevel >= m || L.minShowLevel && !L.maxShowLevel && L.minShowLevel <= m || !L.minShowLevel && L.maxShowLevel && L.maxShowLevel >= m) && (s.save(), s.textBaseline = "top", 0 !== o[v] && (s.fillStyle = "rgba(255,255,255,0.7)", s.textAlign = "center", s.textBaseline = "middle", s.fillText(o[v], parseInt(f) + c / 2, parseInt(w) + c / 2)), s.restore()) } } }, honeycombGrid: function (t) { var e, a, i = t.data, r = t.nwMc, n = t.size, s = t.zoomUnit, o = t.ctx, l = {}, h = this._this.gridStep = Math.round(n / s), m = this._this.depthX = h, p = this._this.depthY = 3 * h / 4, c = 2 * n * 3 / 4, g = parseInt(r.y / c + 1, 10) * c, v = (r.y - g) / s; v = this._this.startY = parseInt(v, 10); var d = parseInt(r.x / n, 10) * n, f = (d - r.x) / s; f = this._this.startX = parseInt(f, 10); for (var w = parseInt(o.canvas.width + m, 10), x = parseInt(o.canvas.height + p, 10), u = f, y = v, S = !1; x > y;) { for (; w > u;) { var b = S ? u - m / 2 : u; b = parseInt(b, 10), l[b + "|" + y] = l[b + "|" + y] || { x: b, y: y, len: 0 }, u += m } S = !S, u = f, y += p } for (var L in i) { var M = i[L].count, _ = i[L].px, D = i[L].py, z = Math.round((D - v) / p), I = z * p + v, O = Math.round((_ - f) / m), C = O * m + f; if (z % 2 && (C -= m / 2), !(f > C || C > w || v > I || I > x) && l[C + "|" + I]) { l[C + "|" + I].len += M; var R = l[C + "|" + I].len; e = e || R, a = a || R, e = Math.max(e, R), a = Math.min(a, R) } } return { grids: l, max: e, min: a } }, drawHoneycomb: function (t) { var e = this, a = e.formatParam.call(this), i = t.ctx, r = t.grids, n = t.size / t.zoomUnit, s = t.fillColors, o = (t.max - t.min - 1) / s.length, l = t.mapZoom, h = t.sup.getDrawOptions().drowZero || !1; for (var m in r) { var p = r[m].x, c = r[m].y, g = r[m].len, v = g / o | 0; v = v >= s.length ? s.length - 1 : v, v = 0 > v ? 0 : v; var d = t.dataRange.getColorByGradient(g); try { if (a.opacity) { var f = parseInt(d.match(/rgba\(.+?\,.+?\,.+?\,(.+?)\)/)[1] * a.opacity) / 255; d = d.replace(/(rgba\(.+?\,.+?\,.+?\,).+?(\))/, "$1" + f + "$2") } } catch (w) { } var x = t.sup.masker.min && t.sup.masker.min > g, u = t.sup.masker.max && t.sup.masker.max < g; if (g > 0 && !x && !u ? e.draw(p, c, n - 1, d, i) : h && e.draw(p, c, n - 1, "rgba(255,255,255,0.1)", i), t.sup.getDrawOptions().label && t.sup.getDrawOptions().label.show && !x && !u) { var y = e.getDrawOptions().label; (!y.minShowLevel && !y.maxShowLevel || y.minShowLevel && y.maxShowLevel && y.minShowLevel <= l && y.maxShowLevel >= l || y.minShowLevel && !y.maxShowLevel && y.minShowLevel <= l || !y.minShowLevel && y.maxShowLevel && y.maxShowLevel >= l) && 0 !== g && (i.save(), i.textBaseline = "middle", i.textAlign = "center", i.fillStyle = "rgba(255,255,255,0.8)", i.fillText(g, p, c), i.restore()) } } }, draw: function (t, e, a, i, r) { r.beginPath(), r.fillStyle = i, r.moveTo(t, e - a / 2), r.lineTo(t + a / 2, e - a / 4), r.lineTo(t + a / 2, e + a / 4), r.lineTo(t, e + a / 2), r.lineTo(t - a / 2, e + a / 4), r.lineTo(t - a / 2, e - a / 4), r.fill(), r.closePath() }, formatParam: function () { var t = this.getDrawOptions(); t = JSON.stringify(t), t = JSON.parse(t); var e = this.fillColors = [[73, 174, 34], [119, 191, 26], [160, 205, 18], [202, 221, 10], [248, 237, 1], [225, 222, 3], [254, 182, 10], [254, 126, 19], [254, 84, 27], [253, 54, 32]], a = t.size || "50"; return a += t.unit || "px", a = /px$/.test(a) ? parseInt(a, 10) * this.zoomUnit : parseInt(a, 10), t.size = a, t.colors = e, t }, geoCoord2Pixel: function (t) { var e = this._map.toScreen(t); return e }, pixel2GeoCoord: function (t) { var e = this._map.toMap(new a(t.x, t.y)); return e } }) });